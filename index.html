<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Size Calculator</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
        }
        h1 {
            margin-bottom: 20px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 20px;
        }
        .tab-btn {
            padding: 10px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            color: #666;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: color 0.2s, border-color 0.2s;
        }
        .tab-btn:hover {
            color: #333;
        }
        .tab-btn.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Form elements */
        label {
            display: block;
            margin-top: 15px;
            font-weight: 500;
        }
        input[type="number"], input[type="range"] {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            box-sizing: border-box;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-container input[type="range"] {
            flex: 1;
        }
        .slider-value {
            min-width: 50px;
            text-align: right;
        }
        .output {
            margin-top: 25px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 5px;
            line-height: 1.6;
        }

        /* Quick estimate table */
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .result-table th, .result-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: right;
        }
        .result-table th {
            background: #f0f0f0;
            font-weight: 600;
            text-align: center;
        }
        .result-table tr:nth-child(even) {
            background: #fafafa;
        }
        .result-table tr:hover {
            background: #e8f0fe;
        }

        /* Advanced tab max-width */
        #tab-advanced {
            max-width: 500px;
        }
    </style>
</head>
<body>
    <h1>Index Size Calculator</h1>
    <p style="color: #666; margin-top: -10px; margin-bottom: 20px;">A tool to help in dimensioning Bloom Filters for <a href="https://tlemane.github.io/kmindex/" style="color: #0066cc;">kmindex</a></p>

    <div class="tabs">
        <button class="tab-btn active" data-tab="tab-quick">Quick Estimate</button>
        <button class="tab-btn" data-tab="tab-advanced">Advanced</button>
    </div>

    <!-- Quick Estimate Tab -->
    <div id="tab-quick" class="tab-content active">
        <label for="q_n_samples">Number of Samples</label>
        <input type="number" id="q_n_samples" value="2000" min="1">

        <label for="q_fpr">False Positive Rate for <a href="https://github.com/lrobidou/findere" style="color: #0066cc;">findere</a></label>
        <input type="number" id="q_fpr" value="0.25" min="0.0001" max="1" step="0.0001">

        <label for="q_n_partitions">Number of Partitions (i.e. number of files the index will be split into)</label>
        <div class="slider-container">
            <input type="range" id="q_n_partitions" min="0" max="10" value="8">
            <span class="slider-value" id="q_partition_display">256</span>
        </div>

        <div id="quick_output"></div>
    </div>

    <!-- Advanced Tab -->
    <div id="tab-advanced" class="tab-content">
        <label for="bf_size">Bloom Filter Size (bits)</label>
        <input type="number" id="bf_size" value="24204408" min="1">

        <label for="span">Span</label>
        <input type="number" id="span" value="22" min="0">

        <label for="max_kmer_count">Max K-mer Count</label>
        <input type="number" id="max_kmer_count" value="8388607" min="1">

        <label for="fpr">False Positive Rate for <a href="https://github.com/lrobidou/findere" style="color: #0066cc;">findere</a></label>
        <input type="number" id="fpr" value="0.25" min="0.0001" max="1" step="0.01">

        <label for="n_samples">Number of Samples</label>
        <input type="number" id="n_samples" value="2000" min="1">

        <label for="n_partitions">Number of Partitions</label>
        <div class="slider-container">
            <input type="range" id="n_partitions" min="0" max="10" value="8">
            <span class="slider-value" id="partition_display">256</span>
        </div>

        <div id="output" class="output"></div>
    </div>

    <script>
        // --- Tab switching ---
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
        });

        // --- Shared helpers ---
        function sliderToPartitions(val) {
            return Math.pow(2, val);
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            if (bytes < 1024 * 1024 * 1024 * 1024) return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            return (bytes / (1024 * 1024 * 1024 * 1024)).toFixed(2) + ' TB';
        }

        function computeP(f) {
            return -Math.log(f) / (Math.log(2) ** 2);
        }

        function computeBfSize(f, span) {
            return Math.floor((computeP(f) * Math.pow(2, span + 1) + 7) / 8) * 8;
        }

        function computeSpan(kmerCount) {
            return Math.floor(Math.log2(kmerCount));
        }

        function computeMaxKmerCount(span) {
            return Math.pow(2, span + 1) - 1;
        }

        function computeSpanFromBfSize(bfSize, f) {
            const b = ((bfSize + 7) / 8) * 8;
            const p = computeP(f);
            const span = Math.floor(Math.log2(b / p)) - 1;
            return Math.max(0, span);
        }

        function computeIndexSize(bfSize, nSamples, nPartitions) {
            const rowSize = Math.floor((nSamples + 7) / 8);
            const nRows = bfSize;
            const colSize = Math.floor(
                Math.floor((nRows / nPartitions + 63) / 64) * 64 * nPartitions
            );
            return rowSize * colSize + nPartitions * 49;
        }

        // --- Quick Estimate Tab ---
        const qSamplesInput = document.getElementById('q_n_samples');
        const qFprInput = document.getElementById('q_fpr');
        const qPartitionsInput = document.getElementById('q_n_partitions');
        const qPartitionDisplay = document.getElementById('q_partition_display');
        const quickOutput = document.getElementById('quick_output');

        function calculateQuick() {
            const nSamples = parseInt(qSamplesInput.value) || 1;
            const f = parseFloat(qFprInput.value) || 0.25;
            const nPartitions = sliderToPartitions(parseInt(qPartitionsInput.value));
            qPartitionDisplay.textContent = nPartitions;

            let html = '<table class="result-table"><thead><tr>' +
                '<th>Span</th>' +
                '<th>Max K-mer Count</th>' +
                '<th>Bloom Filter Size</th>' +
                '<th>Partition File Size</th>' +
                '<th>Total Index Size</th>' +
                '</tr></thead><tbody>';

            for (let span = 20; span <= 40; span++) {
                const maxKmerCount = computeMaxKmerCount(span);
                const bfSize = computeBfSize(f, span);
                const indexSize = computeIndexSize(bfSize, nSamples, nPartitions);
                const partitionFileSize = indexSize / nPartitions;

                html += '<tr>' +
                    '<td>' + span + '</td>' +
                    '<td>' + maxKmerCount.toLocaleString() + '</td>' +
                    '<td>' + formatBytes(bfSize / 8) + '</td>' +
                    '<td>' + formatBytes(partitionFileSize) + '</td>' +
                    '<td>' + formatBytes(indexSize) + '</td>' +
                    '</tr>';
            }

            html += '</tbody></table>';
            quickOutput.innerHTML = html;
        }

        qSamplesInput.addEventListener('input', calculateQuick);
        qFprInput.addEventListener('input', calculateQuick);
        qPartitionsInput.addEventListener('input', calculateQuick);
        calculateQuick();

        // --- Advanced Tab (existing calculator) ---
        const bfSizeInput = document.getElementById('bf_size');
        const spanInput = document.getElementById('span');
        const maxKmerCountInput = document.getElementById('max_kmer_count');
        const fprInput = document.getElementById('fpr');
        const nSamplesInput = document.getElementById('n_samples');
        const nPartitionsInput = document.getElementById('n_partitions');
        const partitionDisplay = document.getElementById('partition_display');
        const output = document.getElementById('output');

        let updating = false;

        function updateFromBfSize() {
            if (updating) return;
            updating = true;
            const bfSize = parseInt(bfSizeInput.value) || 0;
            const f = parseFloat(fprInput.value) || 0.001;
            const span = computeSpanFromBfSize(bfSize, f);
            const kmerCount = computeMaxKmerCount(span);
            spanInput.value = span;
            maxKmerCountInput.value = kmerCount;
            updating = false;
            calculate();
        }

        function updateFromSpan() {
            if (updating) return;
            updating = true;
            const span = parseInt(spanInput.value) || 0;
            const f = parseFloat(fprInput.value) || 0.001;
            const kmerCount = computeMaxKmerCount(span);
            const bfSize = computeBfSize(f, span);
            maxKmerCountInput.value = kmerCount;
            bfSizeInput.value = bfSize;
            updating = false;
            calculate();
        }

        function updateFromKmerCount() {
            if (updating) return;
            updating = true;
            const kmerCount = parseInt(maxKmerCountInput.value) || 1;
            const f = parseFloat(fprInput.value) || 0.001;
            const span = computeSpan(kmerCount);
            const bfSize = computeBfSize(f, span);
            spanInput.value = span;
            bfSizeInput.value = bfSize;
            updating = false;
            calculate();
        }

        function updateFromFpr() {
            if (updating) return;
            updating = true;
            const span = parseInt(spanInput.value) || 0;
            const f = parseFloat(fprInput.value) || 0.001;
            const bfSize = computeBfSize(f, span);
            bfSizeInput.value = bfSize;
            updating = false;
            calculate();
        }

        function calculate() {
            const bfSize = parseInt(bfSizeInput.value) || 0;
            const nSamples = parseInt(nSamplesInput.value) || 0;
            const nPartitions = sliderToPartitions(parseInt(nPartitionsInput.value));

            partitionDisplay.textContent = nPartitions;

            const rowSize = Math.floor((nSamples + 7) / 8);
            const nRows = bfSize;
            const colSize = Math.floor(
                Math.floor((nRows / nPartitions + 63) / 64) * 64 * nPartitions
            );

            const indexSize = rowSize * colSize + nPartitions * 49;
            const indexSizeStr = formatBytes(indexSize);
            const partitionFileSize = indexSize / nPartitions;
            const partitionFileSizeStr = formatBytes(partitionFileSize);

            output.innerHTML = `
                Size of a row: <strong>${rowSize}</strong> bytes<br>
                Size of a column: <strong>${colSize}</strong> bytes<br>
                The index will be split in <strong>${nPartitions}</strong> files.<br>
                Size of a single partition file: <strong>${partitionFileSize}</strong> bytes (<strong>${partitionFileSizeStr}</strong>)<br>
                The index will require a total of <strong>${indexSize}</strong> bytes (<strong>${indexSizeStr}</strong>) on disk.
            `;
        }

        bfSizeInput.addEventListener('input', updateFromBfSize);
        spanInput.addEventListener('input', updateFromSpan);
        maxKmerCountInput.addEventListener('input', updateFromKmerCount);
        fprInput.addEventListener('input', updateFromFpr);
        nSamplesInput.addEventListener('input', calculate);
        nPartitionsInput.addEventListener('input', calculate);

        calculate();
    </script>
</body>
</html>
