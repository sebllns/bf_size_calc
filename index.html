<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Size Calculator</title>
    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$']] }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 10px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            color: #666;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: color 0.2s, border-color 0.2s;
        }

        .tab-btn:hover {
            color: #333;
        }

        .tab-btn.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Form elements */
        label {
            display: block;
            margin-top: 15px;
            font-weight: 500;
        }

        input[type="number"],
        input[type="range"] {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            box-sizing: border-box;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container input[type="range"] {
            flex: 1;
        }

        .slider-value {
            min-width: 50px;
            text-align: right;
        }

        .output {
            margin-top: 25px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 5px;
            line-height: 1.6;
        }

        /* Quick estimate table */
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .result-table th,
        .result-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: right;
        }

        .result-table th {
            background: #f0f0f0;
            font-weight: 600;
            text-align: center;
        }

        .result-table tr:nth-child(even) {
            background: #fafafa;
        }

        .result-table tr:hover {
            background: #e8f0fe;
        }

        .result-table tfoot td {
            font-weight: 600;
            background: #e8e8e8;
            border-top: 2px solid #bbb;
        }

        /* Advanced tab max-width */
        #tab-advanced {
            max-width: 500px;
        }

        /* Formulas tab */
        #tab-formulas {
            max-width: 600px;
        }

        .formula-section {
            margin-bottom: 30px;
        }

        .formula-section h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        .formula-box {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 12px 16px;
            margin: 10px 0;
            font-family: "Courier New", monospace;
            font-size: 14px;
            line-height: 1.8;
        }

        .formula-result {
            margin-top: 15px;
            padding: 12px 15px;
            background: #e8f4e8;
            border-radius: 5px;
            line-height: 1.6;
        }

        /* Dual range slider */
        .dual-range {
            position: relative;
            height: 30px;
            margin-top: 5px;
        }
        .dual-range input[type="range"] {
            position: absolute;
            width: 100%;
            pointer-events: none;
            appearance: none;
            -webkit-appearance: none;
            background: transparent;
            margin: 0;
            padding: 0;
            top: 0;
        }
        .dual-range input[type="range"]::-webkit-slider-thumb {
            pointer-events: all;
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #0066cc;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            position: relative;
            z-index: 2;
        }
        .dual-range input[type="range"]::-moz-range-thumb {
            pointer-events: all;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #0066cc;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            position: relative;
            z-index: 2;
        }
        .dual-range input[type="range"]:first-child::-webkit-slider-runnable-track {
            height: 4px;
            background: #ddd;
            border-radius: 2px;
        }
        .dual-range input[type="range"]:first-child::-moz-range-track {
            height: 4px;
            background: #ddd;
            border-radius: 2px;
        }
        .dual-range input[type="range"]:last-child::-webkit-slider-runnable-track {
            height: 4px;
            background: transparent;
            border-radius: 2px;
        }
        .dual-range input[type="range"]:last-child::-moz-range-track {
            height: 4px;
            background: transparent;
            border-radius: 2px;
        }
        .dual-range-values {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #333;
        }
        .citation {
            background-color: #f9f9f9;
            border-left: 4px solid #8b6914;
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 4px;
            line-height: 1.6;
            font-size: 14px;
        }

        .citation .citation-title {
            font-size: 15px;
            margin-bottom: 6px;
        }

        .citation .citation-title a {
            color: #0066cc;
        }

        .citation .citation-authors {
            color: #555;
            font-size: 13px;
        }

        .citation .citation-details {
            color: #444;
            margin-top: 4px;
        }

        .citation .citation-details a {
            color: #0066cc;
            font-size: 13px;
        }

        .params-box {
            background-color: #fdf2f0;
            border-left: 4px solid #c0392b;
            padding: 12px 14px;
            margin: 10px 0;
            border-radius: 4px;
        }

        .params-box label {
            margin-top: 8px;
        }

        .params-box label:first-child {
            margin-top: 0;
        }

        .info-box {
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 10px 14px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #1a1a1a;
        }

        .info-box::before {
            content: "ℹ️ ";
        }

        .info-box a {
            color: #0066cc;
        }
    </style>
</head>

<body>
    <h1>Index Size Calculator</h1>
    <p style="color: #666; margin-top: -10px; margin-bottom: 20px;">A tool to help in dimensioning Bloom Filters for <a
            href="https://tlemane.github.io/kmindex/" style="color: #0066cc;">kmindex</a></p>

    <div class="tabs">
        <button class="tab-btn active" data-tab="tab-quick">Quick Estimate</button>
        <button class="tab-btn" data-tab="tab-advanced">Advanced</button>
        <button class="tab-btn" data-tab="tab-formulas">Explanations</button>
        <button class="tab-btn" data-tab="tab-references">References</button>
    </div>

    <!-- Quick Estimate Tab -->
    <div id="tab-quick" class="tab-content active">
        <div class="params-box">
            <label for="q_n_samples">Samples per span</label>
            <input type="number" id="q_n_samples" value="2000" min="1">

            <label for="q_fpr">False Positive Rate (Reduced at query time using <a href="https://github.com/lrobidou/findere"
                    style="color: #0066cc;">findere</a>)</label>
            <input type="number" id="q_fpr" value="0.25" min="0.05" max="1" step="0.05">

            <label>Span Range</label>
            <div class="dual-range">
                <input type="range" id="q_span_min" min="13" max="38" value="20">
                <input type="range" id="q_span_max" min="13" max="38" value="38">
            </div>
            <div class="dual-range-values">
                <span>Min: <strong id="q_span_min_display">20</strong></span>
                <span>Max: <strong id="q_span_max_display">38</strong></span>
            </div>

            <label for="q_n_partitions">Number of Partitions (i.e. number of files the index will be split into)</label>
            <div class="slider-container">
                <input type="range" id="q_n_partitions" min="0" max="10" value="8">
                <span class="slider-value" id="q_partition_display">256</span>
            </div>
        </div>

        <div id="quick_output"></div>
    </div>

    <!-- Formulas Tab -->
    <div id="tab-formulas" class="tab-content">
        <div class="formula-section">
            <h3>From K-mer Count to Bloom Filter Size</h3>
            <p>Given a number of k-mer (<em>kmer_count</em>) and a false positive rate (<em>p</em>), we derive the
                <strong><em>span</em></strong> and the <strong>Bloom filter size</strong> (<em>bf_size</em>) as follows:
            </p>
            <div class="formula-box">
                $$\mathrm{span} = \lfloor \log_2(\mathrm{kmer\_count}) \rfloor$$
                $$\mathrm{max\_kmer\_count} = 2^{\mathrm{span}+1} - 1$$
                $$f = \frac{-\ln(p)}{\ln(2)^2}$$
                $$\mathrm{bf\_size} = \left\lceil \frac{f \times 2^{\mathrm{span}+1}}{8} \right\rceil \times 8
                \quad \text{(bits)}$$
            </div>

            <p>The <strong>actual maximum</strong> number of k-mers that can be indexed into this span is given by
                <em>max_kmer_count</em>.</p>

            <div class="params-box">
                <label for="f_kmer_count">K-mer Count (<em>kmer_count</em>)</label>
                <input type="number" id="f_kmer_count" value="4194304" min="1">

                <label for="f_fpr">False Positive Rate (<em>p</em>)</label>
                <input type="number" id="f_fpr" value="0.25" min="0.05" max="1" step="0.05">
                <p class="info-box">The <a href="https://github.com/lrobidou/findere">findere</a> algorithm optimizes queries by using $(k+z)$-mers to reduce the false positive rate at query time. The actual false positive rate becomes $p^z$. This allows Bloom filters to be built with a higher false positive rate while still providing accurate results, which reduces disk footprint. Usually building your index with $\{k=25,\; p=0.25\}$ and querying with $z=6$ provides a good balance.</p>
            </div>
            <div id="formula_bf_output" class="formula-result"></div>
        </div>

        <div class="formula-section">
            <h3>Index Size</h3>
            <p>Given the Bloom filter size (<em>bf_size</em>), the number of samples (<em>n_samples</em>), and the number of partitions (<em>n_partitions</em>):</p>
            <div class="formula-box">
                $$\mathrm{row\_size} = \left\lceil \frac{\mathrm{n\_samples}}{8} \right\rceil \quad
                \text{(bytes)}$$
                $$\mathrm{col\_size} = \left\lceil \frac{\lfloor \mathrm{bf\_size} / \mathrm{n\_partitions} \rfloor}{64} \right\rceil \times 64 \times \mathrm{n\_partitions} \quad \text{(rows)}$$
                $$\mathrm{index\_size} = \mathrm{row\_size} \times \mathrm{col\_size} + \mathrm{n\_partitions} \times 49
                \quad \text{(bytes)}$$
                $$\mathrm{partition\_file\_size} = \frac{\mathrm{index\_size}}{\mathrm{n\_partitions}} \quad
                \text{(bytes)}$$
            </div>

            <div class="params-box">
                <label for="f_n_samples">Number of Samples (<em>n_samples</em>)</label>
                <input type="number" id="f_n_samples" value="2000" min="1">

                <label for="f_n_partitions">Number of Partitions (<em>n_partitions</em>)</label>
                <div class="slider-container">
                    <input type="range" id="f_n_partitions" min="0" max="10" value="8">
                    <span class="slider-value" id="f_partition_display">256</span>
                </div>
            </div>

            <div id="formula_index_output" class="formula-result"></div>
        </div>
    </div>

    <!-- Advanced Tab -->
    <div id="tab-advanced" class="tab-content">
        <div class="params-box">
            <label for="bf_size">Bloom Filter Size (bits)</label>
            <input type="number" id="bf_size" value="24204408" min="1">

            <label for="span">Span</label>
            <input type="number" id="span" value="22" min="0">

            <label for="max_kmer_count">Max K-mer Count</label>
            <input type="number" id="max_kmer_count" value="8388607" min="1">

            <label for="fpr">False Positive Rate</label>
            <input type="number" id="fpr" value="0.25" min="0.05" max="1" step="0.05">

            <label for="n_samples">Number of Samples</label>
            <input type="number" id="n_samples" value="2000" min="1">

            <label for="n_partitions">Number of Partitions</label>
            <div class="slider-container">
                <input type="range" id="n_partitions" min="0" max="10" value="8">
                <span class="slider-value" id="partition_display">256</span>
            </div>
        </div>

        <div id="output" class="output"></div>
    </div>

    <!-- References Tab -->
    <div id="tab-references" class="tab-content">
        <h3>References</h3>
        <div class="citation">
            <div class="citation-title"><strong><a href="https://github.com/tlemane/kmindex">kmindex</a></strong> &mdash; used for index building</div>
            <div class="citation-authors">Lemane, T., Medvedev, P., Chikhi, R., &amp; Peterlongo, P. (2024).</div>
            <div class="citation-details">
                kmindex: a flexible and efficient k-mer indexing framework for large collections of sequencing data.
                <em>Nature Computational Science</em>.<br>
                <a href="https://doi.org/10.1038/s43588-024-00596-6">https://doi.org/10.1038/s43588-024-00596-6</a>
            </div>
        </div>

        <div class="citation">
            <div class="citation-title"><strong><a href="https://github.com/lrobidou/findere">findere</a></strong> &mdash; used for false positive reduction</div>
            <div class="citation-authors">Robidou, L., &amp; Peterlongo, P. (2021).</div>
            <div class="citation-details">
                findere: fast and precise approximate membership query.
                <em>SPIRE 2021 &mdash; String Processing and Information Retrieval</em>.<br>
                <a href="https://doi.org/10.1007/978-3-030-86692-1_13">https://doi.org/10.1007/978-3-030-86692-1_13</a>
            </div>
        </div>

        <div class="citation">
            <div class="citation-title"><strong><a href="https://logan-search.org/">Logan Search</a></strong> &mdash; source of the span calculation formula</div>
            <div class="citation-authors">Rayan Chikhi, Téo Lemane, Raphaël Loll-Krippleber, Mercè Montoliu-Nerin, Brice Raffestin, Antonio Pedro Camargo, Carson J. Miller, Mateus Bernabe Fiamenghi, Daniel Paiva Agustinho, Sina Majidian, Greg Autric, Maxime Hugues, Junkyoung Lee, Roland Faure, Kristen D. Curry, Jorge A. Moura de Sousa, Eduardo P. C. Rocha, David Koslicki, Paul Medvedev, Purav Gupta, Jessica Shen, Alejandro Morales-Tapia, Kate Sihuta, Peter J. Roy, Grant W. Brown, Robert C. Edgar, Anton Korobeynikov, Martin Steinegger, Caleb A. Lareau, Pierre Peterlongo, Artem Babaian (2024).</div>
            <div class="citation-details">
                Logan: Planetary-Scale Genome Assembly Surveys Life's Diversity.
                <em>bioRxiv</em>.<br>
                <a href="https://doi.org/10.1101/2024.07.30.605881">https://doi.org/10.1101/2024.07.30.605881</a>
            </div>
        </div>
    </div>

    <script>
        // --- Tab switching ---
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
        });

        // --- Shared helpers ---
        function sliderToPartitions(val) {
            return Math.pow(2, val);
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            if (bytes < 1024 * 1024 * 1024 * 1024) return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            return (bytes / (1024 * 1024 * 1024 * 1024)).toFixed(2) + ' TB';
        }

        function computeP(f) {
            return -Math.log(f) / (Math.log(2) ** 2);
        }

        function computeBfSize(f, span) {
            return Math.floor((computeP(f) * Math.pow(2, span + 1) + 7) / 8) * 8;
        }

        function computeSpan(kmerCount) {
            return Math.floor(Math.log2(kmerCount));
        }

        function computeMaxKmerCount(span) {
            return Math.pow(2, span + 1) - 1;
        }

        function computeSpanFromBfSize(bfSize, f) {
            const b = ((bfSize + 7) / 8) * 8;
            const p = computeP(f);
            const span = Math.floor(Math.log2(b / p)) - 1;
            return Math.max(0, span);
        }

        function computeIndexSize(bfSize, nSamples, nPartitions) {
            const rowSize = Math.floor((nSamples + 7) / 8);
            const nRows = bfSize;
            const colSize = Math.floor(
                Math.floor((nRows / nPartitions + 63) / 64) * 64 * nPartitions
            );
            return rowSize * colSize + nPartitions * 49;
        }

        // --- Quick Estimate Tab ---
        const qSamplesInput = document.getElementById('q_n_samples');
        const qFprInput = document.getElementById('q_fpr');
        const qPartitionsInput = document.getElementById('q_n_partitions');
        const qPartitionDisplay = document.getElementById('q_partition_display');
        const qSpanMinInput = document.getElementById('q_span_min');
        const qSpanMaxInput = document.getElementById('q_span_max');
        const qSpanMinDisplay = document.getElementById('q_span_min_display');
        const qSpanMaxDisplay = document.getElementById('q_span_max_display');
        const quickOutput = document.getElementById('quick_output');

        function updateSpanRange() {
            let minVal = parseInt(qSpanMinInput.value);
            let maxVal = parseInt(qSpanMaxInput.value);
            if (minVal > maxVal) {
                // Swap if user drags past the other thumb
                if (this === qSpanMinInput) {
                    qSpanMinInput.value = maxVal;
                    minVal = maxVal;
                } else {
                    qSpanMaxInput.value = minVal;
                    maxVal = minVal;
                }
            }
            qSpanMinDisplay.textContent = minVal;
            qSpanMaxDisplay.textContent = maxVal;
            calculateQuick();
        }

        qSpanMinInput.addEventListener('input', updateSpanRange);
        qSpanMaxInput.addEventListener('input', updateSpanRange);

        function calculateQuick() {
            const nSamples = parseInt(qSamplesInput.value) || 1;
            const f = parseFloat(qFprInput.value) || 0.25;
            const nPartitions = sliderToPartitions(parseInt(qPartitionsInput.value));
            qPartitionDisplay.textContent = nPartitions;

            const spanMin = parseInt(qSpanMinInput.value);
            const spanMax = parseInt(qSpanMaxInput.value);

            let html = '<table class="result-table"><thead><tr>' +
                '<th>Span</th>' +
                '<th>Max K-mer Count</th>' +
                '<th>Bloom Filter Size</th>' +
                '<th>Partition File Size</th>' +
                '<th>Total Index Size</th>' +
                '</tr></thead><tbody>';

            let totalIndexSize = 0;
            let totalPartitionFileSize = 0;

            for (let span = spanMin; span <= spanMax; span++) {
                const maxKmerCount = computeMaxKmerCount(span);
                const bfSize = computeBfSize(f, span);
                const indexSize = computeIndexSize(bfSize, nSamples, nPartitions);
                const partitionFileSize = indexSize / nPartitions;

                totalIndexSize += indexSize;
                totalPartitionFileSize += partitionFileSize;

                html += '<tr>' +
                    '<td>' + span + '</td>' +
                    '<td>' + maxKmerCount.toLocaleString() + '</td>' +
                    '<td>' + bfSize.toLocaleString() + '</td>' +
                    '<td>' + formatBytes(partitionFileSize) + '</td>' +
                    '<td>' + formatBytes(indexSize) + '</td>' +
                    '</tr>';
            }

            html += '</tbody><tfoot><tr>' +
                '<td colspan="3">Total</td>' +
                '<td>' + formatBytes(totalPartitionFileSize) + '</td>' +
                '<td>' + formatBytes(totalIndexSize) + '</td>' +
                '</tr></tfoot></table>';
            quickOutput.innerHTML = html;
        }

        qSamplesInput.addEventListener('input', calculateQuick);
        qFprInput.addEventListener('input', calculateQuick);
        qPartitionsInput.addEventListener('input', calculateQuick);
        calculateQuick();

        // --- Formulas Tab ---
        const fKmerCountInput = document.getElementById('f_kmer_count');
        const fFprInput = document.getElementById('f_fpr');
        const fNSamplesInput = document.getElementById('f_n_samples');
        const fPartitionsInput = document.getElementById('f_n_partitions');
        const fPartitionDisplay = document.getElementById('f_partition_display');
        const formulaBfOutput = document.getElementById('formula_bf_output');
        const formulaIndexOutput = document.getElementById('formula_index_output');

        function calculateFormulas() {
            const kmerCount = parseInt(fKmerCountInput.value) || 1;
            const f = parseFloat(fFprInput.value) || 0.25;
            const nSamples = parseInt(fNSamplesInput.value) || 1;
            const nPartitions = sliderToPartitions(parseInt(fPartitionsInput.value));
            fPartitionDisplay.textContent = nPartitions;

            const span = computeSpan(kmerCount);
            const maxKmerCount = computeMaxKmerCount(span);
            const p = computeP(f);
            const bfSize = computeBfSize(f, span);

            formulaBfOutput.innerHTML =
                '$$\\mathrm{span} = \\lfloor \\log_2(' + kmerCount.toLocaleString() + ') \\rfloor = \\mathbf{' + span + '}$$' +
                '$$\\mathrm{max\\_kmer\\_count} = 2^{' + (span + 1) + '} - 1 = \\mathbf{' + maxKmerCount.toLocaleString() + '}$$' +
                '$$f = \\frac{-\\ln(' + f + ')}{\\ln(2)^2} = \\mathbf{' + p.toFixed(4) + '}$$' +
                '$$\\begin{aligned} \\mathrm{bf\\_size} &= \\left\\lceil \\frac{' + p.toFixed(4) + ' \\times 2^{' + (span + 1) + '}}{8} \\right\\rceil \\times 8 \\\\ &= \\mathbf{' + bfSize.toLocaleString() + '} \\text{ bits} \\quad (\\mathbf{' + formatBytes(bfSize / 8) + '}) \\end{aligned}$$';

            // Index size with partitions
            const rowSize = Math.floor((nSamples + 7) / 8);
            const colSize = Math.floor(
                Math.floor((bfSize / nPartitions + 63) / 64) * 64 * nPartitions
            );
            const indexSize = rowSize * colSize + nPartitions * 49;
            const partitionFileSize = indexSize / nPartitions;

            formulaIndexOutput.innerHTML =
                '$$\\mathrm{row\\_size} = \\left\\lceil \\frac{' + nSamples + '}{8} \\right\\rceil = \\mathbf{' + rowSize + '} \\text{ bytes}$$' +
                '$$\\begin{aligned} \\mathrm{col\\_size} &= \\left\\lceil \\frac{\\lfloor ' + bfSize.toLocaleString() + ' / ' + nPartitions + ' \\rfloor}{64} \\right\\rceil \\times 64 \\times ' + nPartitions + ' \\\\ &= \\mathbf{' + colSize.toLocaleString() + '} \\text{ rows} \\end{aligned}$$' +
                '$$\\begin{aligned} \\mathrm{index\\_size} &= ' + rowSize + ' \\times ' + colSize.toLocaleString() + ' + ' + nPartitions + ' \\times 49 \\\\ &= \\mathbf{' + indexSize.toLocaleString() + '} \\text{ bytes} \\quad (\\mathbf{' + formatBytes(indexSize) + '}) \\end{aligned}$$' +
                '$$\\begin{aligned} \\mathrm{partition\\_file\\_size} &= \\frac{' + indexSize.toLocaleString() + '}{' + nPartitions + '} \\\\ &= \\mathbf{' + partitionFileSize.toLocaleString() + '} \\text{ bytes} \\quad (\\mathbf{' + formatBytes(partitionFileSize) + '}) \\end{aligned}$$';

            // Re-typeset MathJax for dynamic content
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetClear([formulaBfOutput, formulaIndexOutput]);
                MathJax.typesetPromise([formulaBfOutput, formulaIndexOutput]);
            }
        }

        fKmerCountInput.addEventListener('input', calculateFormulas);
        fFprInput.addEventListener('input', calculateFormulas);
        fNSamplesInput.addEventListener('input', calculateFormulas);
        fPartitionsInput.addEventListener('input', calculateFormulas);
        calculateFormulas();

        // --- Advanced Tab (existing calculator) ---
        const bfSizeInput = document.getElementById('bf_size');
        const spanInput = document.getElementById('span');
        const maxKmerCountInput = document.getElementById('max_kmer_count');
        const fprInput = document.getElementById('fpr');
        const nSamplesInput = document.getElementById('n_samples');
        const nPartitionsInput = document.getElementById('n_partitions');
        const partitionDisplay = document.getElementById('partition_display');
        const output = document.getElementById('output');

        let updating = false;

        function updateFromBfSize() {
            if (updating) return;
            updating = true;
            const bfSize = parseInt(bfSizeInput.value) || 0;
            const f = parseFloat(fprInput.value) || 0.001;
            const span = computeSpanFromBfSize(bfSize, f);
            const kmerCount = computeMaxKmerCount(span);
            spanInput.value = span;
            maxKmerCountInput.value = kmerCount;
            updating = false;
            calculate();
        }

        function updateFromSpan() {
            if (updating) return;
            updating = true;
            const span = parseInt(spanInput.value) || 0;
            const f = parseFloat(fprInput.value) || 0.001;
            const kmerCount = computeMaxKmerCount(span);
            const bfSize = computeBfSize(f, span);
            maxKmerCountInput.value = kmerCount;
            bfSizeInput.value = bfSize;
            updating = false;
            calculate();
        }

        function updateFromKmerCount() {
            if (updating) return;
            updating = true;
            const kmerCount = parseInt(maxKmerCountInput.value) || 1;
            const f = parseFloat(fprInput.value) || 0.001;
            const span = computeSpan(kmerCount);
            const bfSize = computeBfSize(f, span);
            spanInput.value = span;
            bfSizeInput.value = bfSize;
            updating = false;
            calculate();
        }

        function updateFromFpr() {
            if (updating) return;
            updating = true;
            const span = parseInt(spanInput.value) || 0;
            const f = parseFloat(fprInput.value) || 0.001;
            const bfSize = computeBfSize(f, span);
            bfSizeInput.value = bfSize;
            updating = false;
            calculate();
        }

        function calculate() {
            const bfSize = parseInt(bfSizeInput.value) || 0;
            const nSamples = parseInt(nSamplesInput.value) || 0;
            const nPartitions = sliderToPartitions(parseInt(nPartitionsInput.value));

            partitionDisplay.textContent = nPartitions;

            const rowSize = Math.floor((nSamples + 7) / 8);
            const nRows = bfSize;
            const colSize = Math.floor(
                Math.floor((nRows / nPartitions + 63) / 64) * 64 * nPartitions
            );

            const indexSize = rowSize * colSize + nPartitions * 49;
            const indexSizeStr = formatBytes(indexSize);
            const partitionFileSize = indexSize / nPartitions;
            const partitionFileSizeStr = formatBytes(partitionFileSize);

            output.innerHTML = `
                Size of a row: <strong>${rowSize}</strong> bytes<br>
                Size of a column: <strong>${colSize}</strong> rows<br>
                The index will be split into <strong>${nPartitions}</strong> files.<br>
                Size of a single partition file: <strong>${partitionFileSize}</strong> bytes (<strong>${partitionFileSizeStr}</strong>)<br>
                The index will require a total of <strong>${indexSize}</strong> bytes (<strong>${indexSizeStr}</strong>) on disk.
            `;
        }

        bfSizeInput.addEventListener('input', updateFromBfSize);
        spanInput.addEventListener('input', updateFromSpan);
        maxKmerCountInput.addEventListener('input', updateFromKmerCount);
        fprInput.addEventListener('input', updateFromFpr);
        nSamplesInput.addEventListener('input', calculate);
        nPartitionsInput.addEventListener('input', calculate);

        calculate();
    </script>
</body>

</html>
